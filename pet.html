<!DOCTYPE html>
<html lang="vi">
  <head>
    <meta charset="UTF-8" />
    <title>Game Nu√¥i Th√∫ ·∫¢o</title>
    <!-- THAY ƒê·ªîI 1: TH√äM TH∆Ø VI·ªÜN PH√ÅO HOA -->
    <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>
    <style>
      body {
        margin: 0;
        font-family: "Segoe UI", sans-serif;
        background: linear-gradient(135deg, #1a1a2e, #16213e);
        color: #fff;
        display: flex;
        justify-content: center;
        align-items: center;
        min-height: 100vh;
      }
      .app {
        width: 900px;
        background: rgba(255, 255, 255, 0.05);
        border-radius: 20px;
        padding: 30px;
        box-shadow: 0 10px 25px rgba(0, 0, 0, 0.4);
        position: relative; /* C·∫ßn thi·∫øt cho ph√°o hoa */
        overflow: hidden; /* C·∫ßn thi·∫øt cho ph√°o hoa */
      }
      h1 {
        text-align: center;
        font-size: 24px;
        font-weight: bold;
        margin-top: 0;
        margin-bottom: 25px;
      }
      .container {
        display: flex;
        gap: 20px;
      }

      .pet-column {
        flex: 1.2;
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
        text-align: center;
      }

      .pet-stage {
        position: relative;
        width: 100%;
        height: 120px;
        margin-bottom: 10px;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        overflow: hidden;
      }

      .pet-display {
        position: absolute;
        left: 50%;
        bottom: 0;
        width: 120px;
        height: 120px;
        transform: translateX(-50%);
        transition: left 2s ease-in-out;
      }

      #petImage {
        width: 100%;
        height: 100%;
        object-fit: contain;
        cursor: pointer;
        transition: transform 0.5s;
      }

      #petImage:active {
        transform: var(--transform-direction, scaleX(1)) scale(0.95);
      }

      #petName {
        font-size: 20px;
        font-weight: bold;
      }
      #petMood {
        font-style: italic;
        color: #a3e635; /* M√†u m·∫∑c ƒë·ªãnh */
        margin-top: -15px;
        margin-bottom: 15px;
        min-height: 20px;
        transition: color 0.5s; /* Th√™m hi·ªáu ·ª©ng chuy·ªÉn m√†u */
      }
      .stats {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 10px;
        margin: 15px 0;
      }
      .stat {
        background: rgba(255, 255, 255, 0.05);
        border-radius: 10px;
        padding: 10px;
        font-size: 14px;
        text-align: left;
      }
      .actions {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 12px;
      }
      .game-column {
        flex: 1;
        display: flex;
        flex-direction: column;
        gap: 20px;
      }
      .panel {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 15px;
        padding: 20px;
      }
      .panel-group {
        display: flex;
        gap: 10px;
        margin-bottom: 15px;
      }
      .panel-group input {
        flex: 1;
        padding: 8px 12px;
        border-radius: 10px;
        border: none;
        outline: none;
        background: #0f3460;
        color: #fff;
      }
      .log {
        height: 150px;
        overflow-y: auto;
        background: rgba(0, 0, 0, 0.2);
        border-radius: 10px;
        padding: 10px;
        font-size: 14px;
        margin-top: 10px;
      }
      .log p {
        margin: 5px 0;
      }
      .game-stats {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 15px;
      }
      #levelDisplay {
        font-weight: bold;
        font-size: 18px;
      }
      #coinDisplay {
        font-weight: bold;
        font-size: 18px;
        background: #f2c94c;
        color: #333;
        padding: 5px 10px;
        border-radius: 10px;
      }
      .exp-bar-container {
        background: rgba(0, 0, 0, 0.4);
        border-radius: 20px;
        padding: 3px;
        position: relative; /* << TH√äM D√íNG N√ÄY */
      }
      .exp-bar {
        height: 15px;
        background: linear-gradient(90deg, #4facfe, #00f2fe);
        border-radius: 20px;
        width: 0%;
        transition: width 0.5s;
      }
      .mini-game h3 {
        margin-top: 0;
      }
      .mini-game p {
        font-size: 14px;
        opacity: 0.8;
      }
      .btn {
        padding: 10px 14px;
        border-radius: 10px;
        border: none;
        cursor: pointer;
        font-weight: bold;
        transition: 0.3s;
        color: #fff;
      }
      .btn:hover {
        opacity: 0.8;
      }
      .btn:disabled {
        opacity: 0.5;
        cursor: not-allowed;
        background: #555;
      }
      .btn-primary {
        background: linear-gradient(135deg, #00f2fe, #4facfe);
      }
      .btn-secondary {
        background: linear-gradient(135deg, #43e97b, #38f9d7);
      }
      .stat-bar-container {
        width: 100%;
        height: 8px;
        background-color: rgba(0, 0, 0, 0.4);
        border-radius: 10px;
        margin-top: 8px;
        overflow: hidden;
      }
      .stat-bar {
        height: 100%;
        border-radius: 10px;
        width: 100%;
        transition: width 0.5s ease;
      }
      .countdown-timer {
        font-size: 0.8em;
        opacity: 0.7;
        margin-left: 8px;
        font-family: "Courier New", Courier, monospace;
      }
      #wakeUpNowBtn {
        display: none;
      }
      .exp-text {
        position: absolute;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 12px;
        color: white;
        user-select: none; /* NgƒÉn ng∆∞·ªùi d√πng v√¥ t√¨nh b√¥i ƒëen ch·ªØ */
      }
      .love-tree {
        position: absolute;
        right: 15px; /* N·∫±m ·ªü g√≥c ph·∫£i */
        bottom: 0;
        width: 80px; /* K√≠ch th∆∞·ªõc c√¢y */
        height: 80px;
        cursor: pointer;
        transition: transform 0.2s;
      }
      .love-tree:hover {
        transform: scale(1.05);
      }
      .love-tree img {
        width: 100%;
        height: 100%;
        object-fit: contain;
      }
    </style>
  </head>
  <body>
    <div class="app">
      <h1>Nu√¥i Th√∫</h1>
      <div class="container">
        <div class="pet-column">
          <div class="game-stats">
            <div id="levelDisplay">Level 1</div>
            <div id="coinDisplay">üí∞ 10</div>
          </div>
          <div class="exp-bar-container">
            <div id="expBar" class="exp-bar"></div>
            <!-- X√≥a vƒÉn b·∫£n ·ªü ƒë√¢y -->
            <div id="expText" class="exp-text"></div>
            <!-- Th√™m th·∫ª div m·ªõi cho vƒÉn b·∫£n -->
          </div>
          <hr style="border-color: rgba(255, 255, 255, 0.1); margin: 20px 0" />

          <div class="pet-stage">
            <div class="pet-display">
              <img
                src=""
                alt="pet"
                id="petImage"
                onclick="miniGameClick()"
                title="Click v√†o ƒë√¢y ƒë·ªÉ ch∆°i!"
              />
            </div>
            <div id="loveTree" class="love-tree">
              <img src="" alt="C√¢y T√¨nh Y√™u" />
            </div>
          </div>

          <h2 id="petName">ƒêang t·∫£i...</h2>
          <p id="petMood">...</p>

          <div class="stats">
            <div class="stat">
              <span>H·∫°nh ph√∫c: <span id="happy">...</span></span
              ><span class="countdown-timer" id="happyTimer">(...)</span>
              <div class="stat-bar-container">
                <div
                  id="happyBar"
                  class="stat-bar"
                  style="background-color: #f2c94c"
                ></div>
              </div>
            </div>
            <div class="stat">
              <span>ƒê·ªô no: <span id="hunger">...</span></span
              ><span class="countdown-timer" id="hungerTimer">(...)</span>
              <div class="stat-bar-container">
                <div
                  id="hungerBar"
                  class="stat-bar"
                  style="background-color: #f2994a"
                ></div>
              </div>
            </div>
            <div class="stat">
              <span>NƒÉng l∆∞·ª£ng: <span id="energy">...</span></span
              ><span class="countdown-timer" id="energyTimer">(...)</span>
              <div class="stat-bar-container">
                <div
                  id="energyBar"
                  class="stat-bar"
                  style="background-color: #27ae60"
                ></div>
              </div>
            </div>
            <div class="stat">
              <span>S·∫°ch s·∫Ω: <span id="clean">...</span></span
              ><span class="countdown-timer" id="cleanTimer">(...)</span>
              <div class="stat-bar-container">
                <div
                  id="cleanBar"
                  class="stat-bar"
                  style="background-color: #2d9cdb"
                ></div>
              </div>
            </div>
          </div>

          <!-- === THAY ƒê·ªîI 1: C·∫¨P NH·∫¨T VƒÇN B·∫¢N TR√äN C√ÅC N√öT B·∫§M === -->
          <div class="actions">
            <button
              class="btn btn-primary"
              id="feedBtn"
              onclick="doAction('feed')"
            >
              üçñ Cho ƒÉn (+50 EXP)
            </button>
            <button
              class="btn btn-secondary"
              id="playBtn"
              onclick="doAction('play')"
            >
              üéæ Ch∆°i (+50 EXP)
            </button>
            <button
              class="btn btn-primary"
              id="sleepBtn"
              onclick="doAction('sleep')"
            >
              üõèÔ∏è Ng·ªß (+50 EXP)
            </button>
            <button
              class="btn btn-secondary"
              id="wakeUpNowBtn"
              onclick="doAction('wakeup')"
            >
              ‚òÄÔ∏è Xong Ngay
            </button>
            <button
              class="btn btn-secondary"
              id="bathBtn"
              onclick="doAction('bath')"
            >
              üõÅ T·∫Øm (+50 EXP)
            </button>
          </div>
        </div>
        <div class="game-column">
          <div class="panel">
            <div class="panel-group">
              <input type="text" id="newName" placeholder="ƒê·ªïi t√™n pet..." />
              <button class="btn btn-primary" onclick="renamePet()">
                ƒê·ªïi t√™n
              </button>
            </div>
            <h4>üìú Nh·∫≠t k√Ω h√†nh ƒë·ªông</h4>
            <div class="log" id="log"><p>Ch√†o m·ª´ng b·∫°n!</p></div>
          </div>
          <div class="panel mini-game">
            <h3>üí∞ Mini Game: Pet Clicker!</h3>
            <p>Click li√™n t·ª•c v√†o th√∫ c∆∞ng c·ªßa b·∫°n ·ªü b√™n tr√°i ƒë·ªÉ nh·∫≠n Coins!</p>
          </div>
        </div>
      </div>
    </div>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore-compat.js"></script>
    <script>
      const firebaseConfig = {
        apiKey: "AIzaSyBsumPv8_hk16RcR-mwrx4UVbt8XMzi_2c",
        authDomain: "love-diary-69c00.firebaseapp.com",
        projectId: "love-diary-69c00",
        storageBucket: "love-diary-69c00.appspot.com",
        messagingSenderId: "299225297515",
        appId: "1:299225297515:web:dda7bcb35a0c8ae95af72e",
        measurementId: "G-213TXQLVFX",
      };
      firebase.initializeApp(firebaseConfig);
      const db = firebase.firestore();

      const SINGLE_PET_ID = "the_one_and_only_pet";
      const increment = firebase.firestore.FieldValue.increment;

      const petImages = {
        happy: "https://cdn-icons-png.flaticon.com/512/14984/14984998.png",
        sad: "https://cdn-icons-png.flaticon.com/512/11172/11172315.png",
        sleepy: "https://cdn-icons-png.flaticon.com/512/12400/12400948.png",
        needsBath: "https://cdn-icons-png.flaticon.com/512/11481/11481677.png",
      };
      // === D·ªÆ LI·ªÜU C√ÇY T√åNH Y√äU ===
      function getCurrentMonthString() {
        const now = new Date();
        const year = now.getFullYear();
        const month = String(now.getMonth() + 1).padStart(2, "0"); // Th√°ng b·∫Øt ƒë·∫ßu t·ª´ 0
        return `${year}-${month}`;
      }
      const treeImages = [
        "https://cdn-icons-png.flaticon.com/512/9616/9616995.png", // Level 0 (H·∫°t m·∫ßm)
        "https://cdn-icons-png.flaticon.com/512/6347/6347041.png", // Level 1 (N·∫£y m·∫ßm)
        "https://cdn-icons-png.flaticon.com/512/15142/15142115.png", // Level 2 (C√¢y nh·ªè)
        "https://cdn-icons-png.flaticon.com/512/6667/6667365.png", // Level 3 (C√¢y l·ªõn)
        "https://cdn-icons-png.flaticon.com/512/7144/7144369.png", // Level 4 (Ra hoa)
      ];
      const witheredTreeImage =
        "https://cdn-icons-png.flaticon.com/512/9281/9281106.png"; // C√¢y h√©o
      const FULL_CYCLE_SECONDS = {
        hunger: 3600 * 4,
        energy: 3600 * 4,
        happy: 3600 * 4,
        clean: 3600 * 4,
      };

      const DECAY_RATES = {
        hunger: 100 / FULL_CYCLE_SECONDS.hunger,
        energy: 100 / FULL_CYCLE_SECONDS.energy,
        happy: 100 / FULL_CYCLE_SECONDS.happy,
        clean: 100 / FULL_CYCLE_SECONDS.clean,
      };
      // === B·∫ÆT ƒê·∫¶U CODE M·ªöI: QU·∫¢N L√ù NH·∫¨T K√ù B·∫∞NG FIREBASE ===

      // H√†m n√†y tr·∫£ v·ªÅ ng√†y hi·ªán t·∫°i d∆∞·ªõi ƒë·ªãnh d·∫°ng YYYY-MM-DD
      function getTodayDateString() {
        return new Date().toISOString().split("T")[0];
      }

      // H√†m l·∫Øng nghe v√† c·∫≠p nh·∫≠t nh·∫≠t k√Ω t·ª´ Firestore
      function listenToLogChanges() {
        const logRef = db.collection("logs").doc("daily_activity_log");

        // S·ª≠ d·ª•ng .get() ƒë·ªÉ ƒë·ªçc d·ªØ li·ªáu m·ªôt l·∫ßn v√† quy·∫øt ƒë·ªãnh h√†nh ƒë·ªông
        // thay v√¨ .onSnapshot() ƒë·ªÉ tr√°nh v√≤ng l·∫∑p v√¥ h·∫°n khi x√≥a
        logRef
          .get()
          .then((doc) => {
            const today = getTodayDateString();

            // Tr∆∞·ªùng h·ª£p 1: Document t·ªìn t·∫°i
            if (doc.exists) {
              const logData = doc.data();
              // N·∫øu document l√† c·ªßa ng√†y c≈©
              if (logData.date !== today) {
                console.log("Ph√°t hi·ªán nh·∫≠t k√Ω c≈©, ƒëang x√≥a v√† t·∫°o m·ªõi...");
                // X√≥a document c≈© v√† t·∫°o m·ªõi ngay sau ƒë√≥
                logRef.delete().then(() => {
                  const welcomeMessage = "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ng√†y m·ªõi!";
                  logRef
                    .set({
                      date: today,
                      entries: [welcomeMessage],
                    })
                    .then(() => {
                      // Sau khi t·∫°o m·ªõi th√†nh c√¥ng, b·∫Øt ƒë·∫ßu l·∫Øng nghe thay ƒë·ªïi
                      subscribeToLogUpdates();
                    });
                });
              } else {
                // N·∫øu document l√† c·ªßa ng√†y h√¥m nay, ch·ªâ c·∫ßn b·∫Øt ƒë·∫ßu l·∫Øng nghe
                subscribeToLogUpdates();
              }
            }
            // Tr∆∞·ªùng h·ª£p 2: Document kh√¥ng t·ªìn t·∫°i
            else {
              console.log("Kh√¥ng t√¨m th·∫•y nh·∫≠t k√Ω, ƒëang t·∫°o m·ªõi...");
              const welcomeMessage = "Ch√†o m·ª´ng b·∫°n ƒë·∫øn v·ªõi ng√†y m·ªõi!";
              logRef
                .set({
                  date: today,
                  entries: [welcomeMessage],
                })
                .then(() => {
                  // Sau khi t·∫°o m·ªõi, b·∫Øt ƒë·∫ßu l·∫Øng nghe
                  subscribeToLogUpdates();
                });
            }
          })
          .catch((error) => {
            console.error("L·ªói khi ki·ªÉm tra nh·∫≠t k√Ω:", error);
          });

        // H√†m con ƒë·ªÉ b·∫Øt ƒë·∫ßu l·∫Øng nghe real-time sau khi ƒë√£ ki·ªÉm tra xong
        function subscribeToLogUpdates() {
          logRef.onSnapshot((doc) => {
            const logBox = document.getElementById("log");
            if (doc.exists) {
              const entries = doc.data().entries || [];
              logBox.innerHTML = entries
                .map((msg) => `<p>‚Ä¢ ${msg}</p>`)
                .join("");
              logBox.scrollTop = logBox.scrollHeight;
            }
          });
        }
      }
      // === THAY ƒê·ªîI 2: TH√äM M·∫¢NG L·ªúI NH·∫ÆN V√Ä H√ÄM PH√ÅO HOA ===
      const lovingMessages = [
        "C·∫£m ∆°n b·∫°n ƒë√£ lu√¥n ·ªü b√™n t·ªõ nh√©!",
        "H√†nh tr√¨nh c·ªßa ch√∫ng ta th·∫≠t tuy·ªát v·ªùi!",
        "Y√™u b·∫°n nhi·ªÅu l·∫Øm, ng∆∞·ªùi b·∫°n th√¢n nh·∫•t c·ªßa t·ªõ!",
        "M·ªói ng√†y tr√¥i qua v·ªõi b·∫°n ƒë·ªÅu l√† m·ªôt cu·ªôc phi√™u l∆∞u!",
        "B·∫°n l√† ng∆∞·ªùi ch·ªß tuy·ªát v·ªùi nh·∫•t tr√™n ƒë·ªùi!",
        "Wow! Ch√∫ng ta ƒë√£ ƒë·∫°t m·ªôt c·ªôt m·ªëc l·ªõn!",
        "T√¨nh b·∫°n c·ªßa ch√∫ng ta s·∫Ω c√≤n v∆∞∆°n xa h∆°n n·ªØa!",
      ];

      function triggerFireworks() {
        const duration = 3 * 1000;
        const animationEnd = Date.now() + duration;
        const defaults = {
          startVelocity: 30,
          spread: 360,
          ticks: 60,
          zIndex: 100,
        };

        function randomInRange(min, max) {
          return Math.random() * (max - min) + min;
        }

        const interval = setInterval(function () {
          const timeLeft = animationEnd - Date.now();
          if (timeLeft <= 0) {
            return clearInterval(interval);
          }
          const particleCount = 50 * (timeLeft / duration);
          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.1, 0.3), y: Math.random() - 0.2 },
          });
          confetti({
            ...defaults,
            particleCount,
            origin: { x: randomInRange(0.7, 0.9), y: Math.random() - 0.2 },
          });
        }, 250);
      }

      let petMovementState = { isMoving: false, currentMood: "" };
      let isActionInProgress = false;
      let currentPetState = null;
      let lastKnownLevel = 1; // Bi·∫øn ƒë·ªÉ theo d√µi level

      function initializeApp() {
        listenToLoveTreeChanges();
        listenToLogChanges();
        listenToPetChanges();
        setInterval(petMovementBrain, 4000);
        setInterval(updateLiveStats, 1000);
      }

      function createNewPet() {
        const petRef = db.collection("pets").doc(SINGLE_PET_ID);
        const defaultPet = {
          name: "Mochi (Chung)",
          happy: 100,
          hunger: 100,
          energy: 100,
          clean: 100,
          mood: "Vui v·∫ª",
          level: 1,
          exp: 0,
          coins: 10,
          updatedAt: firebase.firestore.FieldValue.serverTimestamp(),
          isSleeping: false,
          wakeUpTime: null,
        };
        petRef.set(defaultPet).then(() => {
          lastKnownLevel = 1; // Reset level khi t·∫°o pet m·ªõi
          logAction(`Ch√†o m·ª´ng! ƒê√£ t·∫°o ho·∫∑c t·∫£i l·∫°i pet chung c·ªßa m·ªçi ng∆∞·ªùi!`);
        });
      }

      function listenToPetChanges() {
        db.collection("pets")
          .doc(SINGLE_PET_ID)
          .onSnapshot((doc) => {
            if (doc.exists) {
              const data = doc.data();

              // === THAY ƒê·ªîI 3: LOGIC KI·ªÇM TRA LEVEL UP ƒê·∫∂C BI·ªÜT ===
              const newLevel = data.level || 1;
              if (newLevel > lastKnownLevel) {
                if (newLevel % 20 === 0) {
                  triggerFireworks();
                  const randomMessage =
                    lovingMessages[
                      Math.floor(Math.random() * lovingMessages.length)
                    ];
                  logAction(
                    `üíñ ${data.name} (Level ${newLevel}) mu·ªën n√≥i: "${randomMessage}"`
                  );
                }
              }
              lastKnownLevel = newLevel; // C·∫≠p nh·∫≠t level

              currentPetState = {
                ...data,
                updatedAt: data.updatedAt.toDate().getTime(),
                wakeUpTime: data.wakeUpTime
                  ? data.wakeUpTime.toDate().getTime()
                  : null,
              };
              updateUI(data);
            } else {
              createNewPet();
            }
          });
      }

      function formatTime(totalSeconds) {
        if (totalSeconds <= 0) return "00:00:00";
        const h = Math.floor(totalSeconds / 3600);
        const m = Math.floor((totalSeconds % 3600) / 60);
        const s = Math.floor(totalSeconds % 60);
        return `${String(h).padStart(2, "0")}:${String(m).padStart(
          2,
          "0"
        )}:${String(s).padStart(2, "0")}`;
      }

      function determineMood(stats) {
        if (
          stats.hunger <= 0 &&
          stats.happy <= 0 &&
          stats.energy <= 0 &&
          stats.clean <= 0
        )
          return "T·ªá";
        if (stats.isSleeping) return "ƒêang ng·ªß... ZzZ";
        if (stats.energy < 10) return "Bu·ªìn ng·ªß";
        if (stats.hunger < 40) return "H∆°i ƒë√≥i";
        if (stats.happy < 40) return "H∆°i bu·ªìn ch√°n";
        if (stats.clean < 10) return "Mu·ªën th∆°m...";
        return "Vui v·∫ª";
      }

      function updateLiveStats() {
        if (!currentPetState) return;

        const now = Date.now();

        if (currentPetState.isSleeping && now >= currentPetState.wakeUpTime) {
          doAction("wakeup");
          return;
        }

        const lastUpdated = currentPetState.updatedAt;
        const secondsPassed = (now - lastUpdated) / 1000;

        let calculatedStats = {};
        calculatedStats.hunger = Math.max(
          0,
          currentPetState.hunger - secondsPassed * DECAY_RATES.hunger
        );
        calculatedStats.happy = Math.max(
          0,
          currentPetState.happy - secondsPassed * DECAY_RATES.happy
        );
        calculatedStats.energy = Math.max(
          0,
          currentPetState.energy - secondsPassed * DECAY_RATES.energy
        );
        calculatedStats.clean = Math.max(
          0,
          currentPetState.clean - secondsPassed * DECAY_RATES.clean
        );

        const newMood = determineMood({
          ...calculatedStats,
          isSleeping: currentPetState.isSleeping,
        });

        const petMoodEl = document.getElementById("petMood");
        petMoodEl.innerText = `T√¢m tr·∫°ng: ${newMood}`;

        if (newMood === "T·ªá") petMoodEl.style.color = "#ff4757";
        else petMoodEl.style.color = "#a3e635";

        const moodImage = newMood.toLowerCase();
        if (moodImage.includes("ng·ªß")) {
          document.getElementById("petImage").src = petImages.sleepy;
        } else if (moodImage.includes("th∆°m")) {
          document.getElementById("petImage").src = petImages.needsBath;
        } else if (
          moodImage.includes("t·ªá") ||
          moodImage.includes("ƒë√≥i") ||
          moodImage.includes("bu·ªìn")
        ) {
          document.getElementById("petImage").src = petImages.sad;
        } else {
          document.getElementById("petImage").src = petImages.happy;
        }

        // V√≤ng l·∫∑p n√†y b√¢y gi·ªù ch·ªâ ƒë·ªÉ c·∫≠p nh·∫≠t giao di·ªán
        for (const statName in calculatedStats) {
          let currentValue = calculatedStats[statName];

          // S·ª≠a l·ªói hi·ªÉn th·ªã 99 thay v√¨ 100
          if (currentValue > 99) currentValue = 100;
          else currentValue = Math.round(currentValue);

          const lastUpdated = currentPetState.updatedAt;
          const now = Date.now();
          const secondsPassed = (now - lastUpdated) / 1000;
          let timeRemaining = FULL_CYCLE_SECONDS[statName] - secondsPassed;
          if (timeRemaining < 0) timeRemaining = 0;

          document.getElementById(statName).innerText = currentValue;
          document.getElementById(`${statName}Bar`).style.width =
            currentValue + "%";
          document.getElementById(
            `${statName}Timer`
          ).innerText = `(${formatTime(timeRemaining)})`;
        }

        // === KH·ªêI LOGIC V√î HI·ªÜU H√ìA N√öT ƒê√É ƒê∆Ø·ª¢C S·ª¨A L·∫†I ===
        const feedBtn = document.getElementById("feedBtn");
        const playBtn = document.getElementById("playBtn");
        const sleepBtn = document.getElementById("sleepBtn");
        const wakeUpNowBtn = document.getElementById("wakeUpNowBtn");
        const bathBtn = document.getElementById("bathBtn");

        if (currentPetState.isSleeping) {
          feedBtn.disabled = true;
          playBtn.disabled = true;
          bathBtn.disabled = true;
          sleepBtn.style.display = "none";
          wakeUpNowBtn.style.display = "block";
        } else {
          // L·∫•y gi√° tr·ªã ƒë√£ hi·ªÉn th·ªã tr√™n DOM ƒë·ªÉ ƒë·∫£m b·∫£o t√≠nh nh·∫•t qu√°n
          const displayedHunger = parseInt(
            document.getElementById("hunger").innerText
          );
          const displayedHappy = parseInt(
            document.getElementById("happy").innerText
          );
          const displayedEnergy = parseInt(
            document.getElementById("energy").innerText
          );
          const displayedClean = parseInt(
            document.getElementById("clean").innerText
          );

          feedBtn.disabled = displayedHunger >= 100;
          playBtn.disabled = displayedHappy >= 100;
          bathBtn.disabled = displayedClean >= 100;
          sleepBtn.disabled = displayedEnergy >= 100;

          sleepBtn.style.display = "block";
          wakeUpNowBtn.style.display = "none";
        }
      }
      function updateUI(data) {
        document.getElementById("petName").innerText = data.name;
        document.getElementById(
          "levelDisplay"
        ).innerText = `Level ${data.level}`;
        document.getElementById("coinDisplay").innerText = `üí∞ ${data.coins}`;
        const expNeeded = (data.level || 1) * 100;
        const expPercent = Math.min(100, ((data.exp || 0) / expNeeded) * 100);
        const expBar = document.getElementById("expBar");
        const expText = document.getElementById("expText"); // L·∫•y th·∫ª div vƒÉn b·∫£n m·ªõi

        expBar.style.width = expPercent + "%";
        expText.innerText = `${data.exp || 0} / ${expNeeded} EXP`; // Hi·ªÉn th·ªã vƒÉn b·∫£n tr√™n th·∫ª m·ªõi
        updateLiveStats();
      }

      // === THAY ƒê·ªîI 2: C·∫¨P NH·∫¨T L∆Ø·ª¢NG EXP TRONG LOGIC ===
      async function doAction(type) {
        if (isActionInProgress) return;
        isActionInProgress = true;
        const petRef = db.collection("pets").doc(SINGLE_PET_ID);

        try {
          if (type === "bath") {
            document.getElementById("petImage").src = petImages.needsBath;
          }

          await db.runTransaction(async (transaction) => {
            const petDoc = await transaction.get(petRef);
            if (!petDoc.exists) throw new Error("Document does not exist!");

            let data = petDoc.data();
            const now = firebase.firestore.Timestamp.now();

            if (
              type === "wakeup" ||
              (data.isSleeping && now.toMillis() >= data.wakeUpTime.toMillis())
            ) {
              let shouldAddExp = data.energy < 100;
              data.isSleeping = false;
              data.wakeUpTime = null;
              data.energy = 100;
              data.updatedAt = now;
              logAction(`${data.name} ƒë√£ th·ª©c d·∫≠y, tr√†n ƒë·∫ßy nƒÉng l∆∞·ª£ng!`);
              if (type === "wakeup") {
                if (shouldAddExp) {
                  const expNeeded = (data.level || 1) * 100;
                  data.exp = (data.exp || 0) + 50; // Thay ƒë·ªïi ·ªü ƒë√¢y
                  logAction(`B·∫°n nh·∫≠n ƒë∆∞·ª£c 50 EXP!`); // Thay ƒë·ªïi ·ªü ƒë√¢y
                  if (data.exp >= expNeeded) {
                    data.level += 1;
                    data.exp -= expNeeded;
                    data.coins += 50;
                    logAction(
                      `üéâ CH√öC M·ª™NG! ${data.name} ƒë√£ l√™n Level ${data.level}! B·∫°n nh·∫≠n ƒë∆∞·ª£c 50 coins.`
                    );
                  }
                } else {
                  logAction(`NƒÉng l∆∞·ª£ng ƒë√£ ƒë·∫ßy, kh√¥ng nh·∫≠n ƒë∆∞·ª£c EXP!`);
                }
                transaction.update(petRef, data);
                return;
              }
            }

            if (data.isSleeping && type !== "wakeup") {
              logAction(`${data.name} ƒëang ng·ªß, ƒë·ª´ng l√†m phi·ªÅn!`);
              isActionInProgress = false;
              return;
            }

            const lastUpdated = data.updatedAt.toMillis();
            const secondsPassed = (now.toMillis() - lastUpdated) / 1000;

            const oldStats = {
              hunger: Math.max(
                0,
                data.hunger - secondsPassed * DECAY_RATES.hunger
              ),
              happy: Math.max(
                0,
                data.happy - secondsPassed * DECAY_RATES.happy
              ),
              energy: Math.max(
                0,
                data.energy - secondsPassed * DECAY_RATES.energy
              ),
              clean: Math.max(
                0,
                data.clean - secondsPassed * DECAY_RATES.clean
              ),
            };

            data.hunger = oldStats.hunger;
            data.happy = oldStats.happy;
            data.energy = oldStats.energy;
            data.clean = oldStats.clean;

            let actionMsg = "";
            let statToCheck = "";

            switch (type) {
              case "feed":
                statToCheck = "hunger";
                if (data.hunger < 100) {
                  actionMsg = `B·∫°n ƒë√£ cho ${data.name} ƒÉn no n√™!`;
                  let increaseInterval = setInterval(async () => {
                    const petSnap = await petRef.get();
                    if (!petSnap.exists) return clearInterval(increaseInterval);

                    let petData = petSnap.data();
                    if (petData.hunger < 100) {
                      let newHunger = Math.min(100, petData.hunger + 20);
                      await petRef.update({ hunger: newHunger });
                      if (newHunger >= 100) {
                        clearInterval(increaseInterval);
                      }
                    } else {
                      clearInterval(increaseInterval);
                    }
                  }, 1000);
                } else {
                  actionMsg = `${data.name} ƒë√£ no, kh√¥ng ƒÉn th√™m!`;
                }
                break;

              case "play":
                statToCheck = "happy";
                if (data.happy < 100) {
                  actionMsg = `B·∫°n ƒë√£ ch∆°i c√πng ${data.name}! Vui qu√°!`;
                  let increaseInterval = setInterval(async () => {
                    const petSnap = await petRef.get();
                    if (!petSnap.exists) return clearInterval(increaseInterval);

                    let petData = petSnap.data();
                    if (petData.happy < 100) {
                      let newHappy = Math.min(100, petData.happy + 20);
                      await petRef.update({ happy: newHappy });
                      if (newHappy >= 100) {
                        clearInterval(increaseInterval);
                      }
                    } else {
                      clearInterval(increaseInterval);
                    }
                  }, 1000);
                } else {
                  actionMsg = `${data.name} ƒëang r·∫•t vui r·ªìi!`;
                }
                break;

              case "bath":
                statToCheck = "clean";
                if (data.clean < 100) {
                  actionMsg = `${data.name} ƒë√£ ƒë∆∞·ª£c t·∫Øm r·ª≠a s·∫°ch s·∫Ω!`;
                  let increaseInterval = setInterval(async () => {
                    const petSnap = await petRef.get();
                    if (!petSnap.exists) return clearInterval(increaseInterval);
                    let petData = petSnap.data();
                    if (petData.clean < 100) {
                      let newClean = Math.min(100, petData.clean + 20);
                      await petRef.update({
                        clean: newClean,
                      });
                      if (newClean >= 100) {
                        clearInterval(increaseInterval);
                      }
                    } else {
                      clearInterval(increaseInterval);
                    }
                  }, 1000);
                } else {
                  actionMsg = `${data.name} ƒë√£ s·∫°ch s·∫Ω r·ªìi!`;
                }
                break;

              case "sleep":
                statToCheck = "energy";
                if (!data.isSleeping) {
                  data.isSleeping = true;
                  data.wakeUpTime = firebase.firestore.Timestamp.fromMillis(
                    now.toMillis() + 2 * 3600 * 1000
                  );
                  actionMsg = `${data.name} ƒë√£ ƒëi ng·ªß. H·∫πn g·∫∑p l·∫°i sau 2 ti·∫øng!`;
                } else {
                  actionMsg = `${data.name} ƒë√£ ng·ªß r·ªìi.`;
                }
                break;
            }

            if (actionMsg) logAction(actionMsg);

            let shouldAddExp = false;
            if (statToCheck && oldStats[statToCheck] < 100) {
              shouldAddExp = true;
            } else if (statToCheck) {
              logAction(`Ch·ªâ s·ªë ${statToCheck} ƒë√£ ƒë·∫ßy, kh√¥ng nh·∫≠n ƒë∆∞·ª£c EXP!`);
            }

            if (shouldAddExp) {
              const expNeeded = (data.level || 1) * 100;
              data.exp = (data.exp || 0) + 50; // Thay ƒë·ªïi ·ªü ƒë√¢y
              logAction(`B·∫°n nh·∫≠n ƒë∆∞·ª£c 50 EXP!`); // Thay ƒë·ªïi ·ªü ƒë√¢y

              if (data.exp >= expNeeded) {
                data.level += 1;
                data.exp -= expNeeded;
                data.coins = (data.coins || 0) + 50;
                logAction(
                  `üéâ CH√öC M·ª™NG! ${data.name} ƒë√£ l√™n Level ${data.level}! B·∫°n nh·∫≠n ƒë∆∞·ª£c 50 coins.`
                );
              }
            }

            data.updatedAt = now;
            transaction.update(petRef, data);
          });
        } catch (error) {
          console.error("L·ªói transaction:", error);
        } finally {
          isActionInProgress = false;
        }
      }

      function petMovementBrain() {
        if (
          petMovementState.isMoving ||
          (currentPetState && currentPetState.isSleeping)
        )
          return;
        const shouldMove = Math.random() > 0.4;
        if (shouldMove) movePetRandomly();
      }
      function movePetRandomly() {
        petMovementState.isMoving = true;
        const petDisplay = document.querySelector(".pet-display");
        const stage = document.querySelector(".pet-stage");
        const petImage = document.getElementById("petImage");
        const stageWidth = stage.offsetWidth;
        const petWidth = petDisplay.offsetWidth;
        const targetX = Math.random() * (stageWidth - petWidth);
        const currentX = petDisplay.offsetLeft;
        const direction = targetX < currentX ? "scaleX(-1)" : "scaleX(1)";
        petImage.style.setProperty("--transform-direction", direction);
        petImage.style.transform = direction;
        petDisplay.style.left = targetX + "px";
        setTimeout(() => {
          petMovementState.isMoving = false;
        }, 2000);
      }
      function renamePet() {
        if (isActionInProgress) return;

        const newNameInput = document.getElementById("newName");
        const newName = newNameInput.value.trim();
        const currentName = document.getElementById("petName").innerText;

        // 1. Ki·ªÉm tra n·∫øu kh√¥ng nh·∫≠p g√¨
        if (!newName) {
          logAction("‚ö†Ô∏è Vui l√≤ng nh·∫≠p t√™n m·ªõi cho pet!");
          return;
        }

        // 2. Ki·ªÉm tra n·∫øu t√™n m·ªõi tr√πng t√™n c≈©
        if (newName === currentName) {
          logAction(`üí° T√™n c·ªßa pet ƒë√£ l√† "${newName}" r·ªìi!`);
          newNameInput.value = ""; // X√≥a n·ªôi dung trong √¥ input
          return;
        }

        // 3. Ki·ªÉm tra ƒë·ªô d√†i c·ªßa t√™n (v√≠ d·ª•: t·ª´ 3 ƒë·∫øn 15 k√Ω t·ª±)
        if (newName.length < 3 || newName.length > 15) {
          logAction("‚ö†Ô∏è T√™n ph·∫£i c√≥ ƒë·ªô d√†i t·ª´ 3 ƒë·∫øn 15 k√Ω t·ª±!");
          return;
        }

        isActionInProgress = true; // Kh√≥a h√†nh ƒë·ªông sau khi ƒë√£ qua c√°c b∆∞·ªõc ki·ªÉm tra

        db.collection("pets")
          .doc(SINGLE_PET_ID)
          .update({ name: newName })
          .then(() => {
            logAction(`‚ú® B·∫°n ƒë√£ ƒë·ªïi t√™n pet th√†nh "${newName}"`);
            newNameInput.value = ""; // X√≥a n·ªôi dung trong √¥ input
          })
          .catch((error) => {
            console.error("L·ªói khi ƒë·ªïi t√™n: ", error);
            logAction(" R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói x·∫£y ra khi ƒë·ªïi t√™n.");
          })
          .finally(() => {
            isActionInProgress = false; // M·ªü kh√≥a h√†nh ƒë·ªông
          });
      }
      function miniGameClick() {
        if (
          isActionInProgress ||
          (currentPetState && currentPetState.isSleeping)
        )
          return;
        doAction("play");
      }
      function logAction(msg) {
        const logRef = db.collection("logs").doc("daily_activity_log");

        logRef
          .update({
            entries: firebase.firestore.FieldValue.arrayUnion(msg),
          })
          .catch((error) => {
            if (error.code === "not-found") {
              const today = getTodayDateString();
              logRef.set({ date: today, entries: [msg] });
            } else {
              console.error("L·ªói khi c·∫≠p nh·∫≠t nh·∫≠t k√Ω:", error);
            }
          });
      }
      // === C√ÅC H√ÄM X·ª¨ L√ù C√ÇY T√åNH Y√äU ===
      // H√†m l·∫Øng nghe v√† c·∫≠p nh·∫≠t tr·∫°ng th√°i c·ªßa c√¢y
      function listenToLoveTreeChanges() {
        const treeRef = db.collection("loveTree").doc("our_tree");

        treeRef.onSnapshot(
          (doc) => {
            const today = getTodayDateString();
            const currentMonth = getCurrentMonthString();

            if (!doc.exists) {
              treeRef.set({
                level: 0,
                health: 100,
                lastWatered: null,
                reviveCount: 0,
                reviveMonth: currentMonth,
              });
              return;
            }

            let treeData = doc.data();
            let { level, health, lastWatered, reviveCount, reviveMonth } =
              treeData;

            // T·ª∞ ƒê·ªòNG RESET KHI QUA TH√ÅNG M·ªöI N·∫æU C√ÇY ƒê√É H√âO V√Ä H·∫æT L∆Ø·ª¢T C·ª®U
            if (
              health <= 0 &&
              reviveCount >= 3 &&
              reviveMonth !== currentMonth
            ) {
              logAction(
                "üå∏ ƒê√£ sang th√°ng m·ªõi! C√¢y T√¨nh Y√™u ƒë√£ ƒë∆∞·ª£c gieo tr·ªìng l·∫°i."
              );
              treeRef.set({
                // D√πng set ƒë·ªÉ ghi ƒë√® to√†n b·ªô
                level: 0,
                health: 100,
                lastWatered: null,
                reviveCount: 0,
                reviveMonth: currentMonth,
              });
              return; // D·ª´ng l·∫°i ƒë·ªÉ onSnapshot ch·∫°y l·∫°i v·ªõi d·ªØ li·ªáu m·ªõi
            }

            if (lastWatered && lastWatered !== today) {
              const lastWateredDate = new Date(lastWatered);
              const todayDate = new Date(today);
              const daysMissed = Math.floor(
                (todayDate - lastWateredDate) / (1000 * 60 * 60 * 24)
              );

              if (daysMissed > 0) {
                const newHealth = Math.max(0, health - daysMissed * 25);
                if (newHealth !== health) {
                  treeRef.update({ health: newHealth });
                  treeData.health = newHealth;
                }
              }
            }

            const treeImageEl = document.querySelector("#loveTree img");
            if (treeData.health <= 0) {
              treeImageEl.src = witheredTreeImage;
            } else {
              const displayLevel = Math.min(
                treeData.level,
                treeImages.length - 1
              );
              treeImageEl.src = treeImages[displayLevel];
            }

            document.getElementById("loveTree").onclick = () =>
              waterTheTree(treeData);
          },
          (error) => {
            console.error("L·ªói khi l·∫Øng nghe C√¢y T√¨nh Y√™u:", error);
            logAction("‚ö†Ô∏è Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i C√¢y T√¨nh Y√™u.");
          }
        );
      }

      // H√†m x·ª≠ l√Ω h√†nh ƒë·ªông t∆∞·ªõi c√¢y

      async function waterTheTree(treeData) {
        if (isActionInProgress) return;
        const today = getTodayDateString();
        const currentMonth = getCurrentMonthString();

        let { health, level, lastWatered, reviveCount, reviveMonth } = treeData;

        if (lastWatered === today) {
          logAction(
            "‚ù§Ô∏è C√¢y ƒë√£ ƒë∆∞·ª£c t∆∞·ªõi h√¥m nay r·ªìi. H√£y quay l·∫°i v√†o ng√†y mai nh√©!"
          );
          return;
        }

        const treeRef = db.collection("loveTree").doc("our_tree");

        if (health <= 0) {
          // N·∫øu ƒë√£ sang th√°ng m·ªõi, reset l∆∞·ª£t h·ªìi sinh
          if (reviveMonth !== currentMonth) {
            reviveCount = 0;
            logAction("Th√°ng m·ªõi, hy v·ªçng m·ªõi! B·∫°n c√≥ 3 l∆∞·ª£t h·ªìi sinh c√¢y.");
          }

          if (reviveCount >= 3) {
            logAction(
              `ü•Ä C√¢y ƒë√£ h√©o v√† b·∫°n ƒë√£ h·∫øt l∆∞·ª£t h·ªìi sinh trong th√°ng n√†y. H√£y quay l·∫°i v√†o th√°ng sau.`
            );
            return;
          }

          logAction("ü•Ä C√¢y ƒë√£ h√©o... C√πng nhau chƒÉm s√≥c l·∫°i t·ª´ ƒë·∫ßu n√†o!");
          const newReviveCount = reviveCount + 1;
          await treeRef.update({
            health: 25,
            level: 0,
            lastWatered: today,
            reviveCount: newReviveCount,
            reviveMonth: currentMonth,
          });
          logAction(
            `üå± C√¢y ƒë√£ ƒë∆∞·ª£c h·ªìi sinh! (C√≤n ${
              3 - newReviveCount
            } l∆∞·ª£t trong th√°ng).`
          );
          return;
        }
        // B∆Ø·ªöC 2: N·∫æU C√ÇY V·∫™N S·ªêNG, M·ªöI KI·ªÇM TRA XEM ƒê√É T∆Ø·ªöI CH∆ØA
        if (lastWatered === today) {
          logAction(
            "‚ù§Ô∏è C√¢y ƒë√£ ƒë∆∞·ª£c t∆∞·ªõi h√¥m nay r·ªìi. H√£y quay l·∫°i v√†o ng√†y mai nh√©!"
          );
          return;
        }

        isActionInProgress = true;
        try {
          let newHealth = Math.min(100, health + 25);
          let newLevel = level;

          if (health < 100 && newHealth >= 100) {
            newLevel++;
            logAction(
              `üå≥ C√¢y T√¨nh Y√™u ƒë√£ l·ªõn th√™m m·ªôt ch√∫t! (Level ${newLevel})`
            );
          }

          await treeRef.update({
            health: newHealth,
            level: newLevel,
            lastWatered: today,
          });

          logAction("üíß Hai b·∫°n ƒë√£ c√πng nhau t∆∞·ªõi c√¢y T√¨nh Y√™u!");
        } catch (error) {
          console.error("L·ªói khi t∆∞·ªõi c√¢y:", error);
          logAction("R·∫•t ti·∫øc, ƒë√£ c√≥ l·ªói khi t∆∞·ªõi c√¢y.");
        } finally {
          isActionInProgress = false;
        }
      }
      // ================================================================
      // === B·ªò C√îNG C·ª§ M√î PH·ªéNG C√ÇY T√åNH Y√äU (D√ÄNH CHO KI·ªÇM TH·ª¨) ===
      // ================================================================

      // // C√¥ng c·ª• ch√≠nh, c√≥ th·ªÉ g·ªçi tr·ª±c ti·∫øp t·ª´ Console
      // function simulateTree(scenario) {
      //   const treeRef = db.collection("loveTree").doc("our_tree");
      //   let updates = {};

      //   switch (scenario) {
      //     case "wither":
      //       console.log("M√¥ ph·ªèng: L√ÄM C√ÇY H√âO");
      //       alert("Chu·∫©n b·ªã l√†m c√¢y h√©o (health = 0).");
      //       updates = { health: 0 };
      //       break;

      //     case "revive":
      //       console.log("M√¥ ph·ªèng: PH·ª§C H·ªíI C√ÇY HO√ÄN TO√ÄN");
      //       alert("Chu·∫©n b·ªã ph·ª•c h·ªìi c√¢y v·ªÅ tr·∫°ng th√°i ban ƒë·∫ßu.");
      //       updates = {
      //         health: 100,
      //         level: 0,
      //         lastWatered: null,
      //         reviveCount: 0,
      //         reviveMonth: getCurrentMonthString(),
      //       };
      //       break;

      //     case "use_all_revives":
      //       console.log("M√¥ ph·ªèng: D√ôNG H·∫æT L∆Ø·ª¢T H·ªíI SINH");
      //       alert(
      //         "Chu·∫©n b·ªã l√†m c√¢y h√©o V√Ä d√πng h·∫øt 3 l∆∞·ª£t h·ªìi sinh c·ªßa th√°ng n√†y."
      //       );
      //       updates = {
      //         health: 0,
      //         reviveCount: 3,
      //         reviveMonth: getCurrentMonthString(),
      //       };
      //       break;

      //     case "next_month":
      //       console.log("M√¥ ph·ªèng: CHUY·ªÇN SANG TH√ÅNG SAU");
      //       alert(
      //         "Chu·∫©n b·ªã gi·∫£ l·∫≠p tr·∫°ng th√°i c·ªßa c√¢y nh∆∞ th·ªÉ ƒë√£ ·ªü th√°ng tr∆∞·ªõc."
      //       );
      //       const lastMonth = new Date();
      //       lastMonth.setMonth(lastMonth.getMonth() - 1);
      //       const lastMonthString = `${lastMonth.getFullYear()}-${String(
      //         lastMonth.getMonth() + 1
      //       ).padStart(2, "0")}`;
      //       updates = { reviveMonth: lastMonthString };
      //       break;

      //     default:
      //       console.log(
      //         "K·ªãch b·∫£n kh√¥ng h·ª£p l·ªá. C√°c k·ªãch b·∫£n c√≥ s·∫µn: 'wither', 'revive', 'use_all_revives', 'next_month'"
      //       );
      //       return;
      //   }

      //   treeRef
      //     .update(updates)
      //     .then(() => alert(`M√¥ ph·ªèng k·ªãch b·∫£n '${scenario}' th√†nh c√¥ng!`))
      //     .catch((error) =>
      //       console.error(`L·ªói khi m√¥ ph·ªèng k·ªãch b·∫£n '${scenario}':`, error)
      //     );
      // }

      initializeApp();
    </script>
  </body>
</html>
